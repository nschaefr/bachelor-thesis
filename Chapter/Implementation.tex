\chapter{Implementation}\label{chapter:impl}
Die Implementation dient der Umsetzung des im Kapitel \ref{chapter:concept} erstellten Konzepts, sodass ein Testerstellungssystem \textit{Unitcraft} zur Analyse des Hauptthemas bereitgestellt wird. Es erfolgt abschließend ein Testlauf des Programms, um die Funktionalität gewährleisten zu können. Der vollständige Quelltext ist ebenso unter \href{https://github.com/nschaefr/unitcraft}{github.com/nschaefr/unitcraft} abrufbar.

\section{Funktionalitäten}
Die im Konzept festgelegten Zielfunktionalitäten müssen mit Blick auf den Programmablaufplan [Abb. \ref{fig:pap}] zur erfolgreichen Bearbeitung der Arbeit umgesetzt werden. Dabei ist zu beachten, dass alle Funktionalitäten abgedeckt sind sowie alle Komponenten dem Konzept entsprechend zusammenarbeiten. Diese werden auf unterschiedliche Python-Dateien verteilt, um eine Struktur innerhalb des Projektes zu bewahren. Abbildung \ref{fig:dir-proj} zeigt diese Projektstruktur.\input{Assets/LaTeX/Dirtree_project.tex}

\subsection{Nutzerabfrage}
Die Nutzerabfrage dient zur Initialisierung und ermöglicht es dem Nutzer zu Beginn des Programms die Prompt-Technik sowie die dazugehörige Temperatur festzulegen. Diese Funktionalität wird direkt in der \textit{main.py} [Anhang \ref{lst:main}] implementiert. Zum Erstellen einer interaktiven Befragung im Terminal ist der Import der Python-Bibliothek \textit{inquirer} notwendig. Quellcode \ref{lst:input} zeigt die Implementierung von und Verwendung der Bibliothek. Dabei werden 2 Fragen als Liste von \textit{inquirer.List}-Objekten definiert. Die erste Frage stellt dem Benutzer eine Auswahl von vorher festgelegten Prompt-Techniken, die zweite von vorher definierten Temperaturwerten.\\
\lstinputlisting[caption=Interaktive Befragung in \textit{main.py} über \textit{Inquirer},captionpos=b,label={lst:input},language=python]{Assets/Code/input.py}\vspace{-.3cm}
Die Funktion \textit{inquirer.prompt(questions)} wird aufgerufen, um die erstellten Fragen dem Benutzer zu stellen und dessen Antworten in einer Variablen \textit{answers} zu speichern. Im Anschluss wird die Antwort auf die Frage der Prompt-Technik in einer Variablen \textit{prompt\_type} und die Antwort auf die Frage der Temperatur in einer Variablen \textit{temperature} gespeichert. Dies geschieht über das Initialiseren der Variablen mit dem Wert des jeweiligen Listenelements in \textit{answers}.

\subsection{Java-Datei Erfassung im Projekt}
Nach der erfolgreichen Nutzerabfrage wird in \textit{main.py} die Funtion \textit{generate\_unit\_tests} aufgerufen, welche aus \textit{llm.py} [Anhang \ref{lst:llm}] importiert ist. In dieser Funktion erfolgt das Erfassen von Java-Dateien, welche sich im \textit{src}-Verzeichnis befinden über die Funktion \textit{find\_java\_files}. Zum Erstellen von Funktionalitäten die mit Dateien agieren, wird im Unterordner \textit{utils} eine \textit{data\_handler.py} [Anhang \ref{lst:data}] genutzt. Quellcode \ref{lst:find} zeigt die Funktion \textit{find\_java\_files} aus \textit{data\_handler.py}. Zunächst wird eine leere Liste \textit{java\_files} angelegt, um die Pfade der gefundenen Java-Dateien zu speichern. Der Pfad zum Hauptverzeichnis, in dem sich die Java-Dateien befinden, wird in \textit{main\_java\_dir} initialisiert. \\
\lstinputlisting[caption=Funktion zum Erfassen der Java-Dateien in \textit{data\_handler.py},captionpos=b,label={lst:find},language=python]{Assets/Code/find_java_files.py}\vspace{-.3cm}
Dieser ist zusammengesetzt aus dem aktuellen Arbeitsverzeichnis (\textit{working\_dir}) und dem relativen Pfad \textit{src/main}. Das Arbeitsverzeichnis ist eine in \textit{data\_handler.py} definierte Variable und spiegelt das Verzeichnis wieder, in dem das Programm ausgeführt wird. Der Verzeichnisbaum wird ab \textit{main\_java\_dir} über die Funktion \textit{os.walk} rekursiv durchlaufen und jeder Pfad einer gefundenen Java-Datei zur Liste \textit{java\_files} hinzugefügt. Am Ende wird die Liste zurückgegeben. 

\subsection{Prompterstellung}
Um die durch die Nutzerabfrage initialisierten Variablen verwenden zu können, werden sie zunächst als Parameter \textit{generate\_unit\_tests} übergeben. Damit sie innerhalb \textit{llm.py} nutzbar sind, ist die Definition einer kleinen Python-Klasse sinnvoll. [Quellcode \ref{lst:config}] Damit wird ermöglicht, dass die Testparameter über ein Objekt der Klasse \textit{TestConfiguration} abrufbar sind.\\
\lstinputlisting[caption=Python-Klasse für Parameterkonfiguration in \textit{llm.py},captionpos=b,label={lst:config},language=python]{Assets/Code/testconfig.py}\vspace{-.3cm}
In Quellcode \ref{lst:generate-unit} ist zu sehen, wie ein Objekt der Klasse erstellt wird und dessen Attribute mit den Variablen der Nutzerabfrage initialisiert werden. Im Anschluss daran werden die Java-Dateien iterativ durchlaufen. Jeder Dateiinhalt wird nun über die Funktion \textit{read\_java\_file} ausgelesen, in dem \textit{open} die Datei im Lesemouds (r) öffnet und \textit{read} den gesamten Inhalt liest und zurückgibt. [Quellcode \ref{lst:read}] Dieser ist für die Erstellung des Prompts essenziell. Das \textit{config}-Objekt, der Dateipfad sowie der Inhalt der Datei werden \textit{generate\_test\_code} übergeben. [Quellcode \ref{lst:generate-unit}]\\
\lstinputlisting[caption=Funktion zum Vorbereiten der Testcoderstellung in \textit{llm.py},captionpos=b,label={lst:generate-unit},language=python]{Assets/Code/generate_unit.py}\vspace{1cm}
\lstinputlisting[caption=Funktion zum Auslesen des Dateiinhaltes in \textit{data\_handler.py},captionpos=b,label={lst:read},language=python]{Assets/Code/read.py}\vspace{-.3cm}
In der Funktion \textit{generate\_test\_code} findet die Prompterstellung statt.