\chapter{Implementation}\label{chapter:impl}
Die Implementation dient der Umsetzung des im Kapitel \ref{chapter:concept} erstellten Konzepts, sodass ein Testerstellungssystem \textit{Unitcraft} zur Analyse des Hauptthemas bereitgestellt wird. Es erfolgt abschließend ein Testlauf des Programms, um die Funktionalität gewährleisten zu können. Der vollständige Quelltext ist ebenso unter \href{https://github.com/nschaefr/unitcraft}{github.com/nschaefr/unitcraft} abrufbar.

\section{Funktionalitäten}
Die im Konzept festgelegten Zielfunktionalitäten müssen mit Blick auf den Programmablaufplan [Abb. \ref{fig:pap}] zur erfolgreichen Bearbeitung der Arbeit umgesetzt werden. Dabei ist zu beachten, dass alle Funktionalitäten abgedeckt sind sowie alle Komponenten dem Konzept entsprechend zusammenarbeiten. Diese werden auf unterschiedliche Python-Dateien verteilt, um eine Struktur innerhalb des Projektes zu bewahren. Abbildung \ref{fig:dir-proj} zeigt diese Projektstruktur.\input{Assets/LaTeX/Dirtree_project.tex}

\subsection{Nutzerabfrage}
Die Nutzerabfrage dient zur Initialisierung und ermöglicht es dem Nutzer zu Beginn des Programms die Prompt-Technik sowie die dazugehörige Temperatur festzulegen. Diese Funktionalität wird direkt in der \textit{main.py} [Anhang \ref{lst:main}] implementiert. Zum Erstellen einer interaktiven Befragung im Terminal ist der Import der Python-Bibliothek \textit{inquirer} notwendig. Quellcode \ref{lst:input} zeigt die Implementierung und Verwendung der Bibliothek. Dabei werden 2 Fragen als Liste von \textit{inquirer.List}-Objekten definiert. Die erste Frage stellt dem Benutzer eine Auswahl von vorher festgelegten Prompt-Techniken, die zweite von vorher definierten Temperaturwerten.\\
\lstinputlisting[caption=Interaktive Befragung in \textit{main.py} über \textit{Inquirer},captionpos=b,label={lst:input},language=python]{Assets/Code/input.py}\vspace{-.3cm}
Die Funktion \textit{inquirer.prompt(questions)} wird aufgerufen, um die erstellten Fragen dem Benutzer zu stellen und dessen Antworten in einer Variablen \textit{answers} zu speichern. Im Anschluss wird die Antwort auf die Frage der Prompt-Technik in einer Variablen \textit{prompt\_type} und die Antwort auf die Frage der Temperatur in einer Variablen \textit{temperature} gespeichert. Dies geschieht über das Initialiseren der Variablen mit dem Wert des jeweiligen Listenelements in \textit{answers}.

\subsection{Java-Datei Erfassung im Projekt}
Nach der erfolgreichen Nutzerabfrage wird in \textit{main.py} die Funtion \textit{generate\_unit\_tests} aufgerufen, welche aus \textit{llm.py} [Anhang \ref{lst:llm}] importiert ist. In dieser Funktion erfolgt das Erfassen von Java-Dateien, welche sich im \textit{src}-Verzeichnis befinden über die Funktion \textit{find\_java\_files}. Zum Erstellen von Funktionalitäten die mit Dateien agieren, wird im Unterordner \textit{utils} eine \textit{data\_handler.py} [Anhang \ref{lst:data}] genutzt. Quellcode \ref{lst:find} zeigt die Funktion \textit{find\_java\_files} aus \textit{data\_handler.py}. Zunächst wird eine leere Liste \textit{java\_files} angelegt, um die Pfade der gefundenen Java-Dateien zu speichern. Der Pfad zum Hauptverzeichnis, in dem sich die Java-Dateien befinden, wird in \textit{main\_java\_dir} initialisiert. \\
\lstinputlisting[caption=Funktion zum Erfassen der Java-Dateien in \textit{data\_handler.py},captionpos=b,label={lst:find},language=python]{Assets/Code/find_java_files.py}\vspace{-.3cm}
Dieser ist zusammengesetzt aus dem aktuellen Arbeitsverzeichnis (\textit{working\_dir}) und dem relativen Pfad \textit{src/main}. Das Arbeitsverzeichnis ist eine in \textit{data\_handler.py} definierte Variable und spiegelt das Verzeichnis wieder, in dem das Programm ausgeführt wird. Der Verzeichnisbaum wird ab \textit{main\_java\_dir} über die Funktion \textit{os.walk} rekursiv durchlaufen und jeder Pfad einer gefundenen Java-Datei zur Liste \textit{java\_files} hinzugefügt. Am Ende wird die Liste zurückgegeben. 

\subsection{Prompterstellung}
Um die durch die Nutzerabfrage initialisierten Variablen verwenden zu können, werden sie zunächst als Parameter \textit{generate\_unit\_tests} übergeben. Damit sie innerhalb \textit{llm.py} nutzbar sind, ist die Definition einer kleinen Python-Klasse sinnvoll. [Quellcode \ref{lst:config}] Damit wird ermöglicht, dass die Testparameter über ein Objekt der Klasse \textit{TestConfiguration} abrufbar sind.\\
\lstinputlisting[caption=Python-Klasse für Parameterkonfiguration in \textit{llm.py},captionpos=b,label={lst:config},language=python]{Assets/Code/testconfig.py}\vspace{-.3cm}
In Quellcode \ref{lst:generate-unit} ist zu sehen, wie ein Objekt der Klasse erstellt wird und dessen Attribute mit den Variablen der Nutzerabfrage initialisiert werden. Im Anschluss daran werden die Java-Dateien iterativ durchlaufen. Jeder Dateiinhalt wird nun über die Funktion \textit{read\_java\_file} ausgelesen, in dem \textit{open} die Datei im Lesemouds (r) öffnet und \textit{read} den gesamten Inhalt liest und zurückgibt. [Quellcode \ref{lst:read}] Dieser ist für die Erstellung des Prompts essenziell. Das \textit{config}-Objekt, der Dateipfad sowie der Inhalt der Datei werden \textit{generate\_test\_code} übergeben. [Quellcode \ref{lst:generate-unit}]\\
\lstinputlisting[caption=Funktion zum Vorbereiten der Testcoderstellung in \textit{llm.py},captionpos=b,label={lst:generate-unit},language=python]{Assets/Code/generate_unit.py}\vspace{1cm}
\lstinputlisting[caption=Funktion zum Auslesen des Dateiinhaltes in \textit{data\_handler.py},captionpos=b,label={lst:read},language=python]{Assets/Code/read.py}\vspace{-.3cm}
In der Funktion \textit{generate\_test\_code} findet die Prompterstellung statt. Um im Prompt relevante Informationen bereitstellen zu können, müssen bestimmte Teile des Inhalts der Java-Datei extrahiert werden. [Kapitel \ref{section:anford}] Die Funktionalitäten zum Extrahieren werden in \textit{java\_class\_extractor.py} innerhalb einer Klasse \textit{JavaClassExtractor} definiert. [Anhang \ref{lst:class-extr}] Innerhalb der Klasse wird über eine \textit{Regular Expression} ein \textit{Pattern} für den zu extrahierenden Inhalt erstellt, und mithilfe der \textit{re}-Funktion aus der \textit{re}-Bibliothek der Dateiinhalt auf passende Muster durchsucht. Quellcode \ref{lst:regex} zeigt die angelegten \textit{Pattern} der einzelnen Informationen.\\
\lstinputlisting[caption=\textit{RegEx-Pattern} zum Extrahieren von Inhalt in \textit{java\_class\_extractor.py},captionpos=b,label={lst:regex},language=python]{Assets/Code/reg_pattern.py}\vspace{-.3cm}
Das \textit{method\_pattern} wird zum Auffinden von Methoden genutzt und in 2 Extra-Funktionen \textit{extrat\_methods\_with\_content} sowie \textit{extract\_full\_method} verwendet, um den kompletten Methodeninhalt zu extrahieren. Dabei wird in der Methode nach der ersten und letzten geschweiften Klammer gesucht und der Inhalt innerhalb dieser extrahiert und zurückgegeben. [Anhang \ref{lst:class-extr}] Für jedes \textit{Pattern} existiert eine \textit{Get}-Methode, sodass die relevanten Inhalte über ein Klassenobjekt abrufbar sind. Um den Prompt final zu erstellen, ist ein Prompt-\textit{Template} notwendig, welches innerhalb \textit{constants.py} definiert ist. [Anhang \ref{lst:const}] Hier wird der in Abbildung \ref{fig:content-0} und \ref{fig:content-1} erstelle Prompt als String angelegt, welcher anhand der vom Nutzer initialisierten Variable gewählt wird. In \textit{generate\_test\_code} wird nun jede Methode iterativ durchlaufen. Dabei erfolgt die Erstellung des Prompts für die einzelne Methode, wie in Quellcode \ref{lst:prompt} erkennbar. Über das \textit{Dictionary} \textit{prompt\_templates} in \textit{constants.py} wird mithilfe der Variablen für die Prompt-Technik der korrekte Prompt mit den vorher extrahierten Informationen gefüllt.\\
\lstinputlisting[caption=Prompterstellung über \textit{prompt\_templates} in \textit{llm.py},captionpos=b,label={lst:prompt},language=python]{Assets/Code/prompt.py}\vspace{-.3cm}

\subsection{API-Anfrage zur Generierung von Tests}
Die API-Anfrage und somit die Generierung des Testcodes findet in derselben Iteration statt wie die Promperstellung. Zum Durchführen einer API-Anfrage an OpenAI ist die OpenAI-Bibliothek notwendig. Zusätzlich muss eine \textit{.env} angelegt werden, in der sich der \textit{OPENAI\_API\_KEY} befindet. Über die Bibiliothek \textit{load\_dotenv} kann die Funktion \textit{load\_dotenv} aufgerufen werden und somit den Inhalt von \textit{.env} nutzen. Im Anschluss daran folgt die Erstellung eines OpenAI-\textit{clients} mithilfe von \textit{OPENAI\_API\_KEY}, welcher für Anfragen an die API genutzt wird. Quellcode \ref{lst:api} zeigt die Anfrage in der Funktion \textit{prompt\_openai}. Hier ist zu sehen wie der \textit{client} genutzt wird, um eine Chat-Vervollständigung zu fordern. \\
\lstinputlisting[caption=API-Anfrage über OpenAI-\textit{client} in \textit{llm.py},captionpos=b,label={lst:api},language=python]{Assets/Code/prompt_openai.py}\vspace{-.3cm}
Zusätzlich werden Informationen wie \textit{model}, \textit{messages}, \textit{temperature} und \textit{max\_tokens} übergeben. Das \textit{model} wird durch den String ``gpt-4o'' festgelegt und die \textit{temperature} sowie \textit{max\_tokens} über das \textit{config}-Objekt initialisiert. In der Liste \textit{messages} wird der Rolle ``System'' die in Kapitel \ref{section:prompt} definierte Systemanweisung übergeben, welche sich in \textit{constants.py} befindet. Als zweite \textit{message} mit der Rolle ``User'' wird der im vorherigen Kapitel erstellte Prompt bereitgestellt. Die generierte Antwort des Modells wird nun aus der API-Antwort extrahiert in dem wir \textit{choices[0]} und deren Inhalt \textit{message.content} in der Variablen \textit{test\_code} speichern. Da das Sprachmodell aufgrund der Systemanweisung nur Code zurückgibt und dieser in den meisten Fällen im \textit{markdown}-Codeformat formatiert ist, übergeben wir \textit{test\_code} einer Funktion \textit{remove\_format}, welche über ein \textit{Pattern} die Symbole ``\`{}\`{}\`{}'' sucht und über die \textit{strip}-Funktion entfernt. [Quellcode \ref{lst:strip}]\\
\lstinputlisting[caption=Entfernen des \textit{markdown}-Codeformats im \textit{test\_code} in \textit{llm.py},captionpos=b,label={lst:strip},language=python]{Assets/Code/strip.py}\vspace{-.3cm}

\subsection{Testüberprüfung mit Repair Rounds}